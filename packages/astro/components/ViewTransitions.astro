---
type Fallback = 'none' | 'animate' | 'swap';

export interface Props {
	fallback?: Fallback;
}

const { fallback = 'animate' } = Astro.props as Props;
---
<meta name="astro-view-transitions-enabled" content="true">
<meta name="astro-view-transitions-fallback" content={fallback}>
<script>
	type Fallback = 'none' | 'animate' | 'swap';
	type Direction = 'forward' | 'back';

	let currentIndex = history.state?.index || 0;
	if(!history.state) {
		history.replaceState({index: currentIndex}, document.title);
	}

	const supportsViewTransitions = !!document.startViewTransition;
	const transitionEnabledOnThisPage = () => !!document.querySelector('[name="astro-view-transitions-enabled"]');

  async function getHTML(href: string) {
    let res = await fetch(href)
    let html = await res.text();
		return { ok: res.ok, html };
  }

	function getFallback(): Fallback {
		let el = document.querySelector('[name="astro-view-transitions-fallback"]');
		if(el) {
			return el.getAttribute('content') as Fallback;
		}
		return 'animate';
	}

	const parser = new DOMParser();

  async function updateDOM(dir: Direction, html: string, fallback: Fallback = 'swap') {
    const doc = parser.parseFromString(html, 'text/html');
		doc.documentElement.dataset.astroTransition = dir;
		const swap = () => document.documentElement.replaceWith(doc.documentElement);

		if(fallback === 'animate') {
			let isAnimating = false;
			addEventListener('animationstart', () => isAnimating = true, { once: true });

			document.documentElement.dataset.astroTransitionFallback = 'old';
			doc.documentElement.dataset.astroTransitionFallback = 'new';
			// Trigger the animations
			addEventListener('animationend', swap, { once: true });
			// If there are no animations, go ahead and swap on next tick
			setTimeout(() => !isAnimating && swap());
		} else {
			swap();
		}
  }

	async function navigate(dir: Direction, href: string) {
		let htmlPromise = getHTML(href);
		let finished: Promise<void>;
		const { html, ok } = await htmlPromise;
		// If there is a problem fetching the new page, just do an MPA navigation to it.
		if(!ok) {
			location.href = href;
		}
		if(supportsViewTransitions) {
			finished = document.startViewTransition(() => updateDOM(dir, html)).finished;
		} else {
			finished = updateDOM(dir, html, getFallback());
		}
		try {
			await finished;
		} finally {
			document.documentElement.removeAttribute('data-astro-transition');
		}
	}

		// Prefetching
	function maybePrefetch(pathname: string) {
		if(document.querySelector(`link[rel=prefetch][href="${pathname}"]`)) return;
		if(navigator.connection){
			let conn = navigator.connection;
			if(conn.saveData || /(2|3)g/.test(conn.effectiveType || '')) return;
		}
		let link = document.createElement('link');
		link.setAttribute('rel', 'prefetch');
		link.setAttribute('href', pathname);
		document.head.append(link);
	}

	if(supportsViewTransitions || getFallback() !== 'none') {
		document.addEventListener('click', (ev) => {
		let link = ev.target;
		if(link instanceof Element && link.tagName !== 'A') {
			link = link.closest('a');
		}
		if (link &&
			link instanceof HTMLAnchorElement &&
			link.href &&
			(!link.target || link.target === '_self') &&
			link.origin === location.origin &&
			ev.button === 0 && // left clicks only
			!ev.metaKey && // new tab (mac)
			!ev.ctrlKey && // new tab (windows)
			!ev.altKey && // download
			!ev.shiftKey &&
			!ev.defaultPrevented &&
			transitionEnabledOnThisPage()
			) {
			ev.preventDefault();
    	navigate('forward', link.href);
			history.pushState({index: currentIndex + 1}, '', link.href);
			currentIndex++;
		}
  });
	window.addEventListener('popstate', () => {
		if(!transitionEnabledOnThisPage()) return;
		const index = history.state?.index ?? (currentIndex + 1);
		const direction: Direction = index > currentIndex ? 'forward' : 'back';
		navigate(direction, location.href);
		currentIndex = index;
	});

	['mouseenter', 'touchstart', 'focus'].forEach(evName => {
		document.addEventListener(evName, ev => {
			if(ev.target instanceof HTMLAnchorElement) {
				let el = ev.target;
				if(el.origin === location.origin && el.pathname !== location.pathname && transitionEnabledOnThisPage()) {
					maybePrefetch(el.pathname);
				}
			}
		}, { passive: true, capture: true });
	});
	}
</script>
