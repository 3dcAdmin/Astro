---
import { Fallback } from 'astro:transitions/client';
export interface Props {
	fallback?: Fallback;
	intraPageTransitions?: boolean;
}

const { fallback = 'animate', intraPageTransitions = false } = Astro.props;
---

<style is:global>
	/* Route announcer */
	.astro-route-announcer {
		position: absolute;
		left: 0;
		top: 0;
		clip: rect(0 0 0 0);
		clip-path: inset(50%);
		overflow: hidden;
		white-space: nowrap;
		width: 1px;
		height: 1px;
	}
</style>
<meta name="astro-view-transitions-enabled" content="true" />
<meta name="astro-view-transitions-fallback" content={fallback} />
{intraPageTransitions && <meta name="astro-view-transitions-intra-page" content="true" />}

{
	/*  Not yet 
<script is:inline>
	// If we can use and want to use Navigation API,
	// we set up this hook to be the first listener in the chain
	// see navigation-adapter.ts for the view transitions side of this connection

	// This inline script in the head executes earlier than a handler in a module could attach
	if (window.navigation?.currentEntry?.getState) {
		// this test might have detected a browser's native API or a good enough polyfill
		window.navigation.addEventListener('navigate', (e) => {
			document.dispatchEvent(new CustomEvent('astro:connect', { detail: e }));
		});
	}
</script>
*/
}

<script>
	import {
		transitionEnabledOnThisPage,
		supportsViewTransitions,
		supportsNavigationAPI,
		getFallback,
		navigate,
	} from 'astro:transitions/client';
	import { navigationHook } from '../dist/transitions/events.js';

	// Prefetching
	function maybePrefetch(pathname: string) {
		if (document.querySelector(`link[rel=prefetch][href="${pathname}"]`)) return;
		// @ts-expect-error: connection might exist
		if (navigator.connection) {
			// @ts-expect-error: connection does exist
			let conn = navigator.connection;
			if (conn.saveData || /(2|3)g/.test(conn.effectiveType || '')) return;
		}
		let link = document.createElement('link');
		link.setAttribute('rel', 'prefetch');
		link.setAttribute('href', pathname);
		document.head.append(link);
	}

	if (supportsViewTransitions || getFallback() !== 'none') {
		document.addEventListener('click', (ev) => {
			let link = ev.target;
			if (link instanceof Element && link.tagName !== 'A') {
				link = link.closest('a');
			}
			// As of Nov 2023, sourceElement has not yet made it into the spec: https://github.com/w3ctag/design-reviews/issues/867
			navigationHook.sourceElement = link;
			if (!supportsNavigationAPI) {
				// This check verifies that the click is happening on an anchor
				// that is going to another page within the same origin. Basically it determines
				// same-origin navigation, but omits special key combos for new tabs, etc.
				if (
					!link ||
					!(link instanceof HTMLAnchorElement) ||
					link.dataset.astroReload !== undefined ||
					link.hasAttribute('download') ||
					!link.href ||
					(link.target && link.target !== '_self') ||
					link.origin !== location.origin ||
					ev.button !== 0 || // left clicks only
					ev.metaKey || // new tab (mac)
					ev.ctrlKey || // new tab (windows)
					ev.altKey || // download
					ev.shiftKey || // new window
					ev.defaultPrevented
				) {
					// No page transitions in these cases,
					// Let the browser standard action handle this
					return;
				}
				ev.preventDefault();
				navigate(link.href, {
					history: link.dataset.astroHistory === 'replace' ? 'replace' : 'auto',
				});
			}
		});
	}
	if (supportsViewTransitions || getFallback() !== 'none') {
		['mouseenter', 'touchstart', 'focus'].forEach((evName) => {
			document.addEventListener(
				evName,
				(ev) => {
					if (ev.target instanceof HTMLAnchorElement) {
						let el = ev.target;
						if (
							el.origin === location.origin &&
							el.pathname !== location.pathname &&
							transitionEnabledOnThisPage()
						) {
							maybePrefetch(el.pathname);
						}
					}
				},
				{ passive: true, capture: true }
			);
		});
	}
</script>
