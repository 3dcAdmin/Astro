import { existsSync } from 'node:fs';
import { mkdir, writeFile } from 'node:fs/promises';
import {
	getAstroStudioFileServerUrl,
	getProjectIdFromFile,
	getSessionIdFromFile,
} from '@astrojs/studio';
import type { AstroConfig } from 'astro';
import { STORAGE_CODE_FILE, STORAGE_TYPES_FILE } from './consts.js';
import { getAstroStudioStorageUrl } from './utils.js';

export async function codegen(astroConfig: Pick<AstroConfig, 'root'>) {
	await codegenInternal({ root: astroConfig.root });
}

async function codegenInternal({ root }: { root: URL }) {
	const dotAstroDir = new URL('.astro/', root);
	const serveUrl = getAstroStudioFileServerUrl();

	const images = await storageRequest('image', serveUrl);
	const all = await storageRequest('all', serveUrl);

	const code = `
		// This file is auto-generated by Astro Studio. Do not modify this file directly.
		export const images = ${JSON.stringify(images)};
		export const all = ${JSON.stringify(all)};

		export type Image = keyof typeof images | string & {};
		export type File = keyof typeof all | string & {};
	`;

	const types = `
	// This file is auto-generated by Astro Studio. Do not modify this file directly.
	declare module 'astro:storage' {
		export function getFile(name: import("./${STORAGE_CODE_FILE}").File);
		export function getStudioImage(name: import("./${STORAGE_CODE_FILE}").Image);
	}
	`;

	if (!existsSync(dotAstroDir)) {
		await mkdir(dotAstroDir);
	}

	await writeFile(new URL(STORAGE_CODE_FILE, dotAstroDir), code);
	await writeFile(new URL(STORAGE_TYPES_FILE, dotAstroDir), types);
}

async function storageRequest(fileKind: 'all' | 'image' = 'all', serveUrl: string) {
	const projectId = await getProjectIdFromFile();
	const linkUrl = getAstroStudioStorageUrl();
	const sessionToken = await getSessionIdFromFile();

	const response = await safeFetch(
		linkUrl,
		{
			method: 'POST',
			headers: {
				Authorization: `Bearer ${sessionToken}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({ projectId, fileKind }),
		},
		(res) => {
			// Unauthorized
			if (res.status === 401) {
			}
		}
	);

	return rearrangeData((await response.json()).data, serveUrl);
}

function rearrangeData(data: any, serveUrl: string) {
	const grouped: Record<string, any> = {};
	for (const item of data) {
		grouped[item.name] = { ...item, serve_url: `${serveUrl}?id=${item.id}` };
	}

	return grouped;
}

/**
 * Small wrapper around fetch that throws an error if the response is not OK. Allows for custom error handling as well through the onNotOK callback.
 */
async function safeFetch(
	url: Parameters<typeof fetch>[0],
	options: Parameters<typeof fetch>[1] = {},
	onNotOK: (response: Response) => void | Promise<void> = () => {
		throw new Error(`Request to ${url} returned a non-OK status code.`);
	}
): Promise<Response> {
	const response = await fetch(url, options);

	if (!response.ok) {
		await onNotOK(response);
	}

	return response;
}
